## WSagger — що, де і як...

### Браузерний інтерфейс

Запускається статичним index.html з кореня проєкту

Працює наступним чином:

0. В лівому вікні слід завантажити файл сценарію (по урлу або з диска). 

1. Додатково можна завантажити файл variants.json з даними про сервери/користувачів для тестування (ці дані також можуть бути включені в сам сценарій). Поки ці дані  не завантажені, світиться повідомлення "No variants data (REST server, socket server, user, etc.) are loaded!!!"

2. При завантеженні http-сценаріїв всі варіянти responses (якущо вони описані в сценарії) доступні для перегляду на вкладці "Expectations".

3. При виконанні сценарію параметри визначаються наступним чином:

* спершу беруться значення default зі scenario.parameters (поза тим формат опису scenario.parameters співпадає з форматом parameters swagger);
* поверх них записуються дані з селекторів (селектори формуються згідно variants, див. п.1);
* і, нарешті, поверх усього записуються дані з тих полів форми, які заповнено користувачем.

4. Сценарій з так сформованими параметрами виконується, результати можна спостерігати в правому вікні.


### Локальна установка і запуск з консолі

    $ git clone {{the_repository}}
    $ cd wsagger
    $ npm install


Запуск сценарію на виконання: 

    ./w {{filename}} 
    ./w {{filename}} --debug 

Запуск цілого каталогу сценаріїв на виконання: 

    ./wa {{dirname}} 


### Приклади сценаріїв — http-запити 

    examples/test_http_success.wsagger.json — тест на успішний доступ до http-сторінки
    examples/test_http_fail.wsagger.json    — тест на неуспішний доступ до http-сторінки
   

#### Запуски в браузері

Успішний запуск — test_http_success.wsagger.json — параметри:
   
    host: infomincer.net   
    path: /
   

#### Запуски з консолі

    ./w examples/test_http_success.wsagger.json 
    ./w examples/test_http_fail.wsagger.json --debug  
    

#### Пакетний запуск з консолі

    ./wa examples


### Приклади сценаріїв — робота з socket.io

Запуск тестового сервера

    cd examples/socket-server
    node start.js

Сервер працює на порту 10002 і виконує наступні функції:

* при конекті — емітить клієнту сповіщення 'connectedTo' {socketId: ...};
* у відповідь на сповіщення 'message' повертає його саме і його 'message_'-копію, наприклад при еміті 'message' {aaa: 'bbb'} з сокету клієнту повинно прийти:
    0. 'message'  {aaa: 'bbb'}
    1. 'message_' {aaa: 'bbb'}

Сценарії:

    examples/test_socket.io_connect.wsagger.json — тест на конект socket.io
    examples/test_socket.io_emit.wsagger.json    — тест на відправку в сокет сповіщення


### Формат опису сценаріїв

#### Поле wsagger

    == "variants"   — означає, що в поточному файлі міститься дерево варіянтів (вибір сервера, користувача, протоколів тощо — для виконання поточного сценарію);
    == "index"      — означає, що в поточному файлі міститься дерево сценаріїв (для вибору одного із);
    будь що инше    — означає, що в поточному файлі міститься сценарій.
   

#### Поле origin

Інформація про сценарій, імпортована при конвертації swagger.json або инших джерел.


#### Поле name

Назва сценарію (показується нагорі в браузерному інтерфейсі і в дереві сценаріїв).
   

#### Поле variants

Дерево варіянтів (вибір сервера, користувача, протоколів тощо — для виконання поточного сценарію) — те ж саме, що може міститись в окремому файлі variants.json 
   

#### Поле parameters

Опис параметрів, близький до swagger-формату — використовується в браузерному інтерфейсі.
    
    name             // назва, яка використовується як ключ в контексті виконання (див. "Обмін значеннями між сценарієм і контекстом")
    type             // поки що не обробляється
    required         // поки що не обробляється
    description      // для вербального опису 
    default          // значення, яке використовується, коли ніяке инше для параметру не вказано
 

#### Поле responses

Опис результатів, імпортований при конвертації swagger.json (поки що не використовується, але відображаеться в браузерному інтерфейсі на закладці [Expectations]).


### Поле functions — користувацькі функції

В сценарії можна описувати довільні JS-функції, кожна з яких викликатиметься з двома параметрами (data, context):
    
    data    — "поточний обʼєкт" 
    context — загальний контекст

Наприклад (в синтаксисі ES6, але, звісно, можна використовувати і класичний):

    "functions": {
       "isString":   "(data)          => (typeof data === 'string')",  // ? чи поточне значення є рядком
       "inContext":  "(data, context) => (data in context)"            // ? чи поточне значення є ключем в контексті
    }    

В такому випадку кожен елемент виду "{{*isString}}" або "{{*inContext}}" в структурі expected робитиме вказану перевірку щодо відповідного обʼєкта даних.  


#### Поле data

Обʼєкт або список обʼєктів, кожен з яких може містити наступні поля:


##### Поле (data.)action

Можливі значення:

* http.request
* https.request
* http_.request
* socket_io.connect
* socket_io.emit
* socket_io.expect
* call.callWsaggerFile (працює тільки в консольному інтерфейсі)
* load.loadFile        (працює тільки в консольному інтерфейсі)
* load.loadJSON        (працює тільки в консольному інтерфейсі)


##### Поле (data.)data

Обʼєкт або список обʼєктів, які передаються в якості параметрів для (data.)action.
   

###### (data.)data для http.request / https.request

Об'єкт з даними запиту, наприклад:

    { 
      "action": "http.request",
      "data": {
        "method": "POST", 
        "host": "abc.ru", 
        "port": 80, 
        "path": "/login", 
        "headers": {
          "Content-Type": "application/x-www-form-urlencoded", "Accept": "application/json"},
          "queryData":"username={{user.username}}&password={{user.password}}"
        }  
      },          
      ...
    }



###### (data.)data для http_.request

Пара [{{протокол}}, {{об'єкт з даними запиту}}], наприклад:

    { 
      "action": "http_.request",
      "data": [
        "https", 
        {
          "method": "GET", 
          "host": "abc.ru", 
          "port": 443, 
          "path": "/", 
        }  
      ],  
      ...
    }


###### (data.)data для socket_io.connect

Об'єкт з полями url і query (необовʼязково), наприклад:

    {
      "action": "socket_io.connect",           
      "data": { 
        "url": "http://{{server.host}}:{{server.port}}{{server.path}}",            
        "query": { "query": "token={{token}}" }
      },
      ...
    }


###### (data.)data для socket_io.emit

Масив, перший елемент якого — назва event'а, решта — параметри, які передається обробнику eventʼа, наприклад:

    { 
      "action"  : "socket_io.emit",
      "data"    : [
        "sendMessage", 
        {
          "type": "user", 
          "recipientId": "{{recipientId}}", 
          "messageText": "{{messageText}}"
        }
      ],
      ...  
    } 


###### (data.)data для socket_io.expect

Значення (data.)data для socket_io.expect не потрібне.


###### (data.)data для call.callWsaggerFile

Список, перший елемент якого — назва файлу, який буде завантажено з диска і виконано, як wsagger-сценарій, а решта параметрів — дані, які будуть передані цьому файлу для виконання (вони повинні бути описані в ньому як список "keysIn"), наприклад:

    { 
      "action"  : "call.callWsaggerFile",
      "data"    : 
        {
          "action": "http.request",
          "data": {
            "method": "POST", 
            "host": "abc.ru", 
            ...
          },
          ...
        },
        ...        
      ],
      ...
    } 



* call.callWsaggerFile (працює тільки в консольному інтерфейсі)
* load.loadFile        (працює тільки в консольному інтерфейсі)
* load.loadJSON        (працює тільки в консольному інтерфейсі)



##### Поле (data.)wait

{ "delay": ... } — час очікування в мілісекундах


##### Поле (data.)expected

Обʼєкт або список обʼєктів, які ми повинні бути отримані в результаті виконання сценарію (для http_ — один обʼєкт, для socket_io — може бути список):


### Обмін значеннями між сценарієм і контекстом

Всі кроки одного сценарію виконуються в контексті певного обʼєкту. При виконанні сценарію в браузері початкові значення в полях контексту визначаються згідно parameters, при виконанні з консолі — згідно консольних аргументів виклику.

При цьому в полях data і expected допустимо використовувати шаблони:

    {{key}}     // в цьому випадку робиться підставновка значення в поле сценарію із відповідного поля контесту

!!! Коли у flow-вікні в рядку "out -->" видно фрагменти на кшталт "{{...}}" — це означає, що для деякого параметру ніяке значення не підставилось.

В полі expected також допустимо використовувати шаблони:
    
    {{!key}}    // в цьому випадку робиться підставновка значення з поле обʼєкта даних у відповідне поле контесту
    {{*key}}    // в цьому випадку поле обʼєкта даних оцінюється шляхом застосування до нього відповідної функції з .functions


### Опис доступів: variants 

В структуру variants можна поміщати набори опціональних параметрів, вибір з яких робиться в  браузері за допомогою відповідних лістбоксів або в консолі за допомогою їх ключів. 

Якщо структури variants немає в файлі сценарію, то при роботі з консолі використовується файл variants.json з поточного каталогу, а при роботі з браузера variants.json може бути завантажений осібно.


### todo

Антоне! Це не для перекладу

* перевірку на наявність токена треба додати в скрипти; я зроблю під це функції, приклад — і будемо мати
* XMLHTTPRequest fails - data?

